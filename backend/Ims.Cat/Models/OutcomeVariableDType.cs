/*
 * Computer Adaptive Testing (CAT) Service OpenAPI (YAML) Definition
 *
 * The Computer Adaptive Testing (CAT) Service enables a standard way of implementing adaptive testing using Question and Test Interoperability (QTI). This service has been described using the IMS Model Driven Specification development approach, this being the Platform Specific Model (PSM) of the service.
 *
 * OpenAPI spec version: 1.0
 * Contact: lmattson@imsglobal.org
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using Newtonsoft.Json;

namespace Ims.Cat.Models
{ 
    /// <summary>
    /// The Item result information related to an &#x27;Outcome Variable&#x27;. 
    /// </summary>
    [DataContract]
    public partial class OutcomeVariableDType : IEquatable<OutcomeVariableDType>
    { 
        /// <summary>
        /// The identifier of the Outcome Variable. Model Primitive Datatype &#x3D; NCName.
        /// </summary>
        /// <value>The identifier of the Outcome Variable. Model Primitive Datatype &#x3D; NCName.</value>
        [Required]
        [DataMember(Name="identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// The cardinality of the Outcome Variable, taken from the corresponding declaration or definition. 
        /// </summary>
        /// <value>The cardinality of the Outcome Variable, taken from the corresponding declaration or definition. </value>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum CardinalityEnum
        {
            /// <summary>
            /// Enum MultipleEnum for multiple
            /// </summary>
            [EnumMember(Value = "multiple")]
            MultipleEnum = 0,
            /// <summary>
            /// Enum OrderedEnum for ordered
            /// </summary>
            [EnumMember(Value = "ordered")]
            OrderedEnum = 1,
            /// <summary>
            /// Enum RecordEnum for record
            /// </summary>
            [EnumMember(Value = "record")]
            RecordEnum = 2,
            /// <summary>
            /// Enum SingleEnum for single
            /// </summary>
            [EnumMember(Value = "single")]
            SingleEnum = 3        }

        /// <summary>
        /// The cardinality of the Outcome Variable, taken from the corresponding declaration or definition. 
        /// </summary>
        /// <value>The cardinality of the Outcome Variable, taken from the corresponding declaration or definition. </value>
        [Required]
        [DataMember(Name="cardinality")]
        public CardinalityEnum? Cardinality { get; set; }

        /// <summary>
        /// The base type of the Outcome Variable, taken from the corresponding declaration of definition. This value is omitted only for variables with record cardinality. 
        /// </summary>
        /// <value>The base type of the Outcome Variable, taken from the corresponding declaration of definition. This value is omitted only for variables with record cardinality. </value>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum BaseTypeEnum
        {
            /// <summary>
            /// Enum BooleanEnum for boolean
            /// </summary>
            [EnumMember(Value = "boolean")]
            BooleanEnum = 0,
            /// <summary>
            /// Enum DirectedPairEnum for directedPair
            /// </summary>
            [EnumMember(Value = "directedPair")]
            DirectedPairEnum = 1,
            /// <summary>
            /// Enum DurationEnum for duration
            /// </summary>
            [EnumMember(Value = "duration")]
            DurationEnum = 2,
            /// <summary>
            /// Enum FileEnum for file
            /// </summary>
            [EnumMember(Value = "file")]
            FileEnum = 3,
            /// <summary>
            /// Enum FloatEnum for float
            /// </summary>
            [EnumMember(Value = "float")]
            FloatEnum = 4,
            /// <summary>
            /// Enum IdentifierEnum for identifier
            /// </summary>
            [EnumMember(Value = "identifier")]
            IdentifierEnum = 5,
            /// <summary>
            /// Enum IntegerEnum for integer
            /// </summary>
            [EnumMember(Value = "integer")]
            IntegerEnum = 6,
            /// <summary>
            /// Enum PairEnum for pair
            /// </summary>
            [EnumMember(Value = "pair")]
            PairEnum = 7,
            /// <summary>
            /// Enum PointEnum for point
            /// </summary>
            [EnumMember(Value = "point")]
            PointEnum = 8,
            /// <summary>
            /// Enum StringEnum for string
            /// </summary>
            [EnumMember(Value = "string")]
            StringEnum = 9,
            /// <summary>
            /// Enum UriEnum for uri
            /// </summary>
            [EnumMember(Value = "uri")]
            UriEnum = 10        }

        /// <summary>
        /// The base type of the Outcome Variable, taken from the corresponding declaration of definition. This value is omitted only for variables with record cardinality. 
        /// </summary>
        /// <value>The base type of the Outcome Variable, taken from the corresponding declaration of definition. This value is omitted only for variables with record cardinality. </value>
        [DataMember(Name="baseType")]
        public BaseTypeEnum? BaseType { get; set; }

        /// <summary>
        /// Gets or Sets View
        /// </summary>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum ViewEnum
        {
            /// <summary>
            /// Enum AuthorEnum for author
            /// </summary>
            [EnumMember(Value = "author")]
            AuthorEnum = 0,
            /// <summary>
            /// Enum CandidateEnum for candidate
            /// </summary>
            [EnumMember(Value = "candidate")]
            CandidateEnum = 1,
            /// <summary>
            /// Enum ProctorEnum for proctor
            /// </summary>
            [EnumMember(Value = "proctor")]
            ProctorEnum = 2,
            /// <summary>
            /// Enum ScorerEnum for scorer
            /// </summary>
            [EnumMember(Value = "scorer")]
            ScorerEnum = 3,
            /// <summary>
            /// Enum TestConstructorEnum for testConstructor
            /// </summary>
            [EnumMember(Value = "testConstructor")]
            TestConstructorEnum = 4,
            /// <summary>
            /// Enum TutorEnum for tutor
            /// </summary>
            [EnumMember(Value = "tutor")]
            TutorEnum = 5        }

        /// <summary>
        /// The views (if any) declared for the outcome must be copied to the report to enable systems that render the report to hide information not relevant in a specific situation. If no values are given, the outcome&#x27;s value should be considered relevant in all views. 
        /// </summary>
        /// <value>The views (if any) declared for the outcome must be copied to the report to enable systems that render the report to hide information not relevant in a specific situation. If no values are given, the outcome&#x27;s value should be considered relevant in all views. </value>
        [DataMember(Name="view")]
        public List<ViewEnum> View { get; set; }

        /// <summary>
        /// A human readable interpretation of the default value. Model Primitive Datatype &#x3D; String.
        /// </summary>
        /// <value>A human readable interpretation of the default value. Model Primitive Datatype &#x3D; String.</value>
        [DataMember(Name="interpretation")]
        public string Interpretation { get; set; }

        /// <summary>
        /// An optional link to an extended interpretation of the outcome variable&#x27;s value. Model Primitive Datatype &#x3D; AnyURI.
        /// </summary>
        /// <value>An optional link to an extended interpretation of the outcome variable&#x27;s value. Model Primitive Datatype &#x3D; AnyURI.</value>
        [DataMember(Name="longInterpretation")]
        public string LongInterpretation { get; set; }

        /// <summary>
        /// The normalMaximum attribute optionally defines the maximum magnitude of numeric outcome variables, it must be a positive value. If given, the outcome&#x27;s value can be divided by normalMaximum and then truncated (if necessary) to obtain a normalized score in the range [-1.0,1.0]. normalMaximum has no affect on responseProcessing or the values that the outcome variable itself can take. Model Primitive Datatype &#x3D; Double.
        /// </summary>
        /// <value>The normalMaximum attribute optionally defines the maximum magnitude of numeric outcome variables, it must be a positive value. If given, the outcome&#x27;s value can be divided by normalMaximum and then truncated (if necessary) to obtain a normalized score in the range [-1.0,1.0]. normalMaximum has no affect on responseProcessing or the values that the outcome variable itself can take. Model Primitive Datatype &#x3D; Double.</value>
        [DataMember(Name="normalMaximum")]
        public double? NormalMaximum { get; set; }

        /// <summary>
        /// The normalMinimum attribute optionally defines the minimum value of numeric outcome variables, it may be negative. Model Primitive Datatype &#x3D; Double.
        /// </summary>
        /// <value>The normalMinimum attribute optionally defines the minimum value of numeric outcome variables, it may be negative. Model Primitive Datatype &#x3D; Double.</value>
        [DataMember(Name="normalMinimum")]
        public double? NormalMinimum { get; set; }

        /// <summary>
        /// The masteryValue attribute optionally defines a value for numeric outcome variables above which the aspect being measured is considered to have been mastered by the candidate. Model Primitive Datatype &#x3D; Double.
        /// </summary>
        /// <value>The masteryValue attribute optionally defines a value for numeric outcome variables above which the aspect being measured is considered to have been mastered by the candidate. Model Primitive Datatype &#x3D; Double.</value>
        [DataMember(Name="masteryValue")]
        public double? MasteryValue { get; set; }

        /// <summary>
        /// The value(s) of the outcome variable. The order of the values is significant only if the outcome was declared with ordered cardinality. 
        /// </summary>
        /// <value>The value(s) of the outcome variable. The order of the values is significant only if the outcome was declared with ordered cardinality. </value>
        [DataMember(Name="value")]
        public List<ValueDType> Value { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class OutcomeVariableDType {\n");
            sb.Append("  Identifier: ").Append(Identifier).Append("\n");
            sb.Append("  Cardinality: ").Append(Cardinality).Append("\n");
            sb.Append("  BaseType: ").Append(BaseType).Append("\n");
            sb.Append("  View: ").Append(View).Append("\n");
            sb.Append("  Interpretation: ").Append(Interpretation).Append("\n");
            sb.Append("  LongInterpretation: ").Append(LongInterpretation).Append("\n");
            sb.Append("  NormalMaximum: ").Append(NormalMaximum).Append("\n");
            sb.Append("  NormalMinimum: ").Append(NormalMinimum).Append("\n");
            sb.Append("  MasteryValue: ").Append(MasteryValue).Append("\n");
            sb.Append("  Value: ").Append(Value).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((OutcomeVariableDType)obj);
        }

        /// <summary>
        /// Returns true if OutcomeVariableDType instances are equal
        /// </summary>
        /// <param name="other">Instance of OutcomeVariableDType to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(OutcomeVariableDType other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    Identifier == other.Identifier ||
                    Identifier != null &&
                    Identifier.Equals(other.Identifier)
                ) && 
                (
                    Cardinality == other.Cardinality ||
                    Cardinality != null &&
                    Cardinality.Equals(other.Cardinality)
                ) && 
                (
                    BaseType == other.BaseType ||
                    BaseType != null &&
                    BaseType.Equals(other.BaseType)
                ) && 
                (
                    View == other.View ||
                    View != null &&
                    View.SequenceEqual(other.View)
                ) && 
                (
                    Interpretation == other.Interpretation ||
                    Interpretation != null &&
                    Interpretation.Equals(other.Interpretation)
                ) && 
                (
                    LongInterpretation == other.LongInterpretation ||
                    LongInterpretation != null &&
                    LongInterpretation.Equals(other.LongInterpretation)
                ) && 
                (
                    NormalMaximum == other.NormalMaximum ||
                    NormalMaximum != null &&
                    NormalMaximum.Equals(other.NormalMaximum)
                ) && 
                (
                    NormalMinimum == other.NormalMinimum ||
                    NormalMinimum != null &&
                    NormalMinimum.Equals(other.NormalMinimum)
                ) && 
                (
                    MasteryValue == other.MasteryValue ||
                    MasteryValue != null &&
                    MasteryValue.Equals(other.MasteryValue)
                ) && 
                (
                    Value == other.Value ||
                    Value != null &&
                    Value.SequenceEqual(other.Value)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (Identifier != null)
                    hashCode = hashCode * 59 + Identifier.GetHashCode();
                    if (Cardinality != null)
                    hashCode = hashCode * 59 + Cardinality.GetHashCode();
                    if (BaseType != null)
                    hashCode = hashCode * 59 + BaseType.GetHashCode();
                    if (View != null)
                    hashCode = hashCode * 59 + View.GetHashCode();
                    if (Interpretation != null)
                    hashCode = hashCode * 59 + Interpretation.GetHashCode();
                    if (LongInterpretation != null)
                    hashCode = hashCode * 59 + LongInterpretation.GetHashCode();
                    if (NormalMaximum != null)
                    hashCode = hashCode * 59 + NormalMaximum.GetHashCode();
                    if (NormalMinimum != null)
                    hashCode = hashCode * 59 + NormalMinimum.GetHashCode();
                    if (MasteryValue != null)
                    hashCode = hashCode * 59 + MasteryValue.GetHashCode();
                    if (Value != null)
                    hashCode = hashCode * 59 + Value.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(OutcomeVariableDType left, OutcomeVariableDType right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(OutcomeVariableDType left, OutcomeVariableDType right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
