/*
 * Computer Adaptive Testing (CAT) Service OpenAPI (YAML) Definition
 *
 * The Computer Adaptive Testing (CAT) Service enables a standard way of implementing adaptive testing using Question and Test Interoperability (QTI). This service has been described using the IMS Model Driven Specification development approach, this being the Platform Specific Model (PSM) of the service.
 *
 * OpenAPI spec version: 1.0
 * Contact: lmattson@imsglobal.org
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using Newtonsoft.Json;

namespace Ims.Cat.Models
{ 
    /// <summary>
    /// This is the context for the &#x27;assessmentResult&#x27;. It provides the corresponding set of identifiers. 
    /// </summary>
    [DataContract]
    public partial class ContextDType : IEquatable<ContextDType>
    { 
        /// <summary>
        /// A unique identifier for the test candidate. Model Primitive Datatype &#x3D; NCName.
        /// </summary>
        /// <value>A unique identifier for the test candidate. Model Primitive Datatype &#x3D; NCName.</value>
        [DataMember(Name="sourcedId")]
        public string SourcedId { get; set; }

        /// <summary>
        /// The system that creates the result (for example, the test delivery system) should assign a session identifier that it can use to identify the session. Subsequent systems that process the result might assign their own identifier to the session which should be added to the context if the result is modified and exported for transport again. 
        /// </summary>
        /// <value>The system that creates the result (for example, the test delivery system) should assign a session identifier that it can use to identify the session. Subsequent systems that process the result might assign their own identifier to the session which should be added to the context if the result is modified and exported for transport again. </value>
        [DataMember(Name="sessionIdentifiers")]
        public List<SessionIdentifierDType> SessionIdentifiers { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class ContextDType {\n");
            sb.Append("  SourcedId: ").Append(SourcedId).Append("\n");
            sb.Append("  SessionIdentifiers: ").Append(SessionIdentifiers).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((ContextDType)obj);
        }

        /// <summary>
        /// Returns true if ContextDType instances are equal
        /// </summary>
        /// <param name="other">Instance of ContextDType to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ContextDType other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    SourcedId == other.SourcedId ||
                    SourcedId != null &&
                    SourcedId.Equals(other.SourcedId)
                ) && 
                (
                    SessionIdentifiers == other.SessionIdentifiers ||
                    SessionIdentifiers != null &&
                    SessionIdentifiers.SequenceEqual(other.SessionIdentifiers)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (SourcedId != null)
                    hashCode = hashCode * 59 + SourcedId.GetHashCode();
                    if (SessionIdentifiers != null)
                    hashCode = hashCode * 59 + SessionIdentifiers.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(ContextDType left, ContextDType right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(ContextDType left, ContextDType right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
